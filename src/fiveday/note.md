## 一、this：
### 1.this的上下文基于函数的调用情况，和函数定义位置无关；
### 2.非严格模式下独立函数调用，this指向全局对象；严格模式下this保持执行上下文时设定的值，没设置默认undefined；
### 3.箭头函数中，this由词法作用域设置，受执行上下文影响不受调用方法影响；
### 4.函数当做对象方法或原型链上的方法调用时，this指向该对象；
### 5.构造函数中，this指向实例；
### 6.call和apply可以指定函数运行时的this；
### 7.bind的this会永久绑定到参数上；
### 8.DOM事件，this绑定到触发事件的dom元素上。
### 9.四种this绑定方式：
        1.默认绑定：什么都匹配不到时，非严格模式下this绑定到全局对象window或global上；严格模式下，this绑定到undefined，会报错（Cannot read property '属性' of undefined）；
        2.隐式绑定：函数作为对象的属性，通过对象属性方式调用，此时this绑定到对象；
        3.显式绑定：使用apply、call；
        4.new绑定：new操作符将this绑定到新对象。
## 二、原型链：
### 1.js只有一种结构——对象。每个对象都有一个私有属性[[prototype]]，指向它的原型对象prototype，该原型对象又有自己的prototype，层层向上直到对象原型是null（Object.prototype=null），null没有原型，作为原型链的最后一环。
### 2.[[prototype]]是对象的原型属性，ES6使用Object.getPrototypeOf()/Object.setPrototypeOf()获取原型，等同于浏览器的非标准属性__proto__。
### 3.只有函数有prototype属性；被构造函数创建的实例对象的[[propotype]]指向function的prototype，对象的[[propotype]]指向自己的构造函数的prototype。
### 4.数组继承Array.prototype，函数继承Function.prototype；
        对象原型链：实例→Object.prototype→null；
        数组原型链：实例→Array.prototype→Object.prototype→null；
        函数原型链：实例→Function.prototype→Object.prototype→null。
### 5.Object.create()创建对象，新对象的原型就是调用create方法传入的第一个参数。
### 6.使用 实例.hasOwnProperty(属性名)可以检查属性和方法是属于自己定义的还是原型链上的。

## 三、继承：
### ECMAScript只有实现继承，实现继承主要依靠原型链实现。
### 实例的__proto__属性指向构造函数的prototype属性。
### 1.原型链继承——利用原型，让一个引用类型继承另一个引用类型的属性和方法
        具体做法：让一个构造函数的原型对象等于要继承的构造函数的实例。
        所有引用类型都默认继承了Object，调用方法时会按照实例方法--构造函数原型方法--构造函数的继承函数的原型方法--...--Object原型方法。
        使用instanceof操作符或isPrototypeOf()函数判断实例与构造函数的关系，只要在原型链出现过的，都是true，注意操作符和函数的使用方法是不同的。
        子类型覆盖或添加超类型中的方法，给原型加/替换方法的语句要在原型替换语句之后，不然就白写了；也不能用对象字面量的方法重写原型，会切断继承。
        缺点：超类型中的引用类型值会被子类型的所有实例共用；创建子类型的时候无法在不影响所有对象实例的前提下给超类型传参。因此一般不单独用原型链继承。
### 2.借用构造函数继承（伪造对象/经典继承）——在子类型构造函数的内部调用超类型的构造函数，用apply和call
        优点：子类型的每个实例都有自己的属性副本；可以向超类型传参（要在调用超类型后再添加自定义属性，以防重写）。
        缺点：超类型中的函数无复用性；子类型无法访问超类型原型中的方法。
### 3.组合继承（伪经典继承）——使用原型链实现属性方法的继承，使用构造函数完成实例属性的继承
        用法：先call()，再让子类型的原型等于超类型的实例。
        优点：有自己的属性副本；可向超类型传参；可复用超类型原型的方法；可被instanceof操作符或isPrototypeOf()函数判断实例与构造函数的关系；最常用。
        缺点：调用两次构造函数；第二次调用时重写了属性。
### 4.原型式继承
### 5.寄生式继承——封装并增强对象最后返回对象
        缺点：函数无法复用
### 6.寄生组合式继承——借用构造函数来继承属性，通过原型链的混成形式来继承方法
        优点：不必为了指定子类型的原型而调用构造函数，避免在原型上创建不必要的属性。

## 四、闭包：
### 概念：定义在函数内部，可以读取其他函数内部变量的函数。
### 本质：词法作用域和函数当作值传递。
### 作用：读取函数内部变量，将变量始终保存在内存中。
### 注意点：
        滥用闭包会过多占用内存影响性能，退出函数之前需把不用的变量删除；
        闭包可以在函数外部改变函数内部的值，不要随便改父函数的值；
        返回函数不可引用循环变量或者后续会发生变化的变，如果一定要引用循环变量，需再创建一个立即执行函数并将变量作为参数传入。